%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  This Beamer template was created by Cameron Bracken.
%%  Anyone can freely use or modify it for any purpose
%%  without attribution.
%%
%%  Last Modified: January 9, 2009
%%

\documentclass[xcolor=x11names,compress]{beamer}

%% General document %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amssymb,amsthm,amsopn}
\usepackage{mathrsfs}
\usepackage{graphicx}
\usepackage{tikz}
%\usepackage{array}
%\usepackage[top=1cm,bottom=1cm]{geometry}
%\usepackage{listings}
%\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=red,
}

\newtheoremstyle{break}%
{}{}%
{\itshape}{}%
{\bfseries}{}%  % Note that final punctuation is omitted.
{\newline}{}

\newtheoremstyle{sc}%
{}{}%
{}{}%
{\scshape}{}%  % Note that final punctuation is omitted.
{\newline}{}

\theoremstyle{break}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lm}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}

\theoremstyle{sc}
\newtheorem{exo}{Exercice}

\theoremstyle{definition}
\newtheorem{defi}[thm]{Definition}
\newtheorem{ex}[thm]{Example}

\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}

% Raccourcis pour les opérateurs mathématiques (les espaces avant-après sont
% modifiés pour mieux rentrer dans les codes mathématiques usuels)
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\Img}{Im}
\DeclareMathOperator{\Card}{Card}
\DeclareMathOperator{\Vect}{Vect}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\Mod}{mod}
\DeclareMathOperator{\Ord}{Ord}
\DeclareMathOperator{\ppcm}{ppcm}


% Nouvelles commandes
\newcommand{\ps}[2]{\left\langle#1,#2\right\rangle}
\newcommand{\ent}[2]{[\![#1,#2]\!]}
\newcommand{\diff}{\mathop{}\!\mathrm{d}}
\newcommand{\ie}{\emph{i.e. }}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Beamer Layout %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\useoutertheme[subsection=false,shadow]{miniframes}
\useinnertheme{default}
\usefonttheme{serif}
\usepackage{palatino}

\setbeamerfont{title like}{shape=\scshape}
\setbeamerfont{frametitle}{shape=\scshape}

\setbeamercolor*{lower separation line head}{bg=DeepSkyBlue4} 
% \setbeamercolor*{normal text}{fg=black,bg=white} 
% \setbeamercolor*{alerted text}{fg=red} 
% \setbeamercolor*{example text}{fg=black} 
% \setbeamercolor*{structure}{fg=black} 
%  
\setbeamercolor*{palette tertiary}{fg=black,bg=black!10} 
\setbeamercolor*{palette quaternary}{fg=black,bg=black!10} 
% 
% \renewcommand{\(}{\begin{columns}}
% \renewcommand{\)}{\end{columns}}
% \newcommand{\<}[1]{\begin{column}{#1}}
% \renewcommand{\>}{\end{column}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \title{Logarithme discret dans les corps finis de petite charactéristique}
%\subtitle{SUBTITLE}
\author{
Édouard Rousseau\\
{\it Université de Versailles\\}
}
\date{\today}
\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Table des matières}
\tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\scshape Introduction}
\subsection{Le problème du logarithme discret}
\begin{frame}{Contexte}
  Soit $G$ un groupe cyclique engendré par un élément $g$, et notons $N$ le
  cardinal de $G$. On a alors une \emph{bijection}
  \[
    \begin{array}{cccc}
      exp_g: & \mathbb{Z}/N\mathbb{Z} & \to & G \\
      & \bar n & \mapsto & g^n
    \end{array}.
  \]

  On note la bijection récriproque $log_g$. 
\end{frame}

\begin{frame}{Le problème du logarithme discret}
  \begin{itemize}
    \item En pratique, étant donné un entier $n$, on dispose d'algorithmes efficaces
  pour calculer $g^n$.
\item Étant donné $x = g^n\in G$, \emph{on ne dispose pas} d'algorithmes efficaces
  pour retrouver $n$.
  \end{itemize}
  C'est ce problème, « Comment retrouver $n$ ? », qu'on appelle \emph{Problème
  du logarithme discret}.
\end{frame}

\begin{frame}{Intérêt en cryptographie}
  En cryptographie, $exp_g$ est appelée \emph{fonction à sens unique} car
  \begin{itemize}
    \item $exp_g$ est facile à calculer
    \item sa réciproque, $log_g$, est difficile à calculer.
  \end{itemize}

  Ces fonctions sont très étudiées en cryptographie car elles permettent
  typiquement de rendre l'opération de cryptage simple et l'opération de
  décryptage longue et compliquée.
\end{frame}

\subsection{Historique}
\begin{frame}{Bref historique du problème}
  Pour exprimer la difficulté d'un problème, on parle de sa complexité et on
  utilise la notation 
  \[
    L_N(\alpha, c) = \exp((c+o(1))(\log N)^\alpha(\log\log N)^{1-\alpha}).
  \]
  On note aussi $L_N(\alpha)$ quand on ne veut pas préciser la constante.

  On distingue deux types d'algorithmes :
  \begin{itemize}
    \item Les algorithmes \emph{génériques} en $O(\sqrt N)$
    \item Les algorithmes de \emph{calcul d'indice}, qui exploitent la structure de
      groupes issus de corps finis : $\mathbb{F}_{q}^\times$
  \end{itemize}
\end{frame}

\begin{frame}{Bref historique du problème}
  \begin{itemize}
    \item Apparition dans ``New directions in cryptography'' de Diffie et
      Hellman (1976)
    \item Premier algorithme sous-exponentiel : Adleman (1979), complexité en
      $L_N(1/2)$
  \item Premier algorithme en $L(1/3)$ dans les corps finis binaires : Coppersmith (1984)
  \item Crible algébrique dans les corps premiers : 1993,
    $L(1/3)$
  \item Crible géométrique, utilisable en petite caractéristique : 1994,
    généralisations en 1999, 2002, 2006; $L(1/3)$
  \item Généralisation du crible algébrique en 2006, on peut dès lors résoudre
    des logarithmes discret en $L(1/3)$ dans tout type de corps fini
  \end{itemize}
\end{frame}

\begin{frame}{Bref historique du problème}
  Et plus récemment, dans les corps finis de petite caractéristique :
  \begin{itemize}
    \item Nouvel algorithme dû à Joux (2013) en $L(1/4)$
    \item Algorithme \emph{quasi-polynomial} dû à Barbulescu, Gaudry, Joux et
      Thomé en 2014
    \item Second algorithme quasi-polynomial dû à Granger, Kleinjung et
      Zumbrägel en 2014
  \end{itemize}
\end{frame}

\section{\scshape Calcul d'indice}
\subsection{Principe général}
\begin{frame}{Principe général}
  Supposons qu'on veuille trouver $log_g(h)$ où $h\in G$. On choisit $F\subset G$ tel que $\left\langle F \right\rangle = G$.
  \begin{enumerate}
    \item On trouve des relations entre les éléments de F
    \item On résout le système linéaire engendré par ces relations
    \item On exprime $h$ en fonction des éléments de $F$
  \end{enumerate}
  Les étapes $1, 2$ et $3$ dépendent du groupe $G$ et de sa représentation, et
  donnent lieu à des complexités différentes selon les cas.
\end{frame}
\begin{frame}{Un exemple}
  \emph{Contexte :}
  \begin{itemize}
    \item On considère $G = \mathbb{F}_p^\times$ pour un nombre premier $p$, on
      a toujours $N = |G|$
    \item On considère $F = \left\{\, f \;|\; f \leq B,\; f \text{ premier} \right\}$ pour
      une certaine borne $B$
    \item On suppose que $g\in F$, sinon on rajoute $g$ dans $F$.
  \end{itemize}
\end{frame}

\subsection{Un exemple}
\begin{frame}{Un exemple}
  \emph{Étape 1 : génération des relations}
  \begin{itemize}
    \item On choisi $e\in \mathbb{Z}/N\mathbb{Z}$ aléatoirement
    \item On calcule $g^e$
    \item On teste si $g^e$, vu comme entier, est $B$-friable, \ie n'a que des
      diviseurs premiers inférieurs à $B$
    \item Si c'est le cas, on a une relation dans $G$ :
      \[ 
        g^e = \prod_{f\in F}f^{e_f}, \text{ où } e_f\in \mathbb{N}
      \]
      qui se traduit en 
      \[
        e = \sum_{f\in F}e_f\log_g(f).
      \]
  \end{itemize}
\end{frame}

\begin{frame}{Un exemple}
  \emph{Étape 2 : algèbre linéaire.} Une fois qu'on a assez de relations, \ie au
  moins $|F|$, on résout le système linéaire obtenu dans
  $\mathbb{Z}/N\mathbb{Z}$ pour obtenir tous les $\log_g(f)$ pour $f\in F$.

  \emph{Étape 3 : exprimer $h$ en fonction des éléments de $F$ :}
  \begin{itemize}
    \item On choisi $e\in \mathbb{Z}/N\mathbb{Z}$ aléatoirement
    \item On calcule $hg^e$
    \item On teste si $hg^e$ est $B$-friable
    \item Si c'est le cas, on a une relation
      \[
      \log_g(h) = \sum_{f\in F}e_f\log_g(f) - e
      \]
  \end{itemize}

\end{frame}

\begin{frame}{Un exemple}
  Cet algorithme dépend du choix de $B$ :
  \begin{itemize}
    \item Lorsque $B$ est grand, $\left\langle F \right\rangle$ est plus grand
      donc il est plus simple de trouver des relations
    \item Mais quand $|F|$ est grand, il faut résoudre un système linéaire plus
      grand également.
  \end{itemize}
  In fine, avec un choix judicieux de $B$, on trouve une complexité en
  $L(1/2)$.
\end{frame}

\section{\scshape Algorithmes quasi-polynomiaux}
\subsection{Terminologie}
\begin{frame}{Définitions}
  Avant d'entrer dans le cœur du sujet, revenons sur quelques points de
  terminologie. Lorsque l'on considère le problème du logarithme discret dans
  une famille de corps finis $\mathbb{F}_{q}$, où $q=p^n$ et $q\to\infty$, les
  algorithmes dépendent de la grandeur relative de $p$ et $n$, si
  $p=L_q(\alpha)$ :
  \begin{itemize}
    \item Si $\alpha>\frac{2}{3}$, on parle de \emph{grande caractéristique}
    \item Si $\frac{1}{3} <\alpha<\frac{2}{3}$, on parle de \emph{moyenne caractéristique}
    \item Si $0 <\alpha<\frac{1}{3}$, on parle de \emph{petite-moyenne caractéristique}
    \item Si $\alpha = 0$, on parle de \emph{petite caractéristique}
  \end{itemize}
\end{frame}


\begin{frame}{Définitions}
 Toujours dans le cadre d'une famille de corps finis $F_q$, un algorithme dont
 la complexité est  $\log q^{O(\log q)}$ est dit \emph{quasi-polynomial}. Cette
 complexité est plus petite que toutes les complexités $L(\varepsilon)$ pour
 $\varepsilon>0$ mais plus grande que tout polynôme en $\log q$.
\end{frame}

\subsection{Algorithme de Barbulescu, Gaudry, Joux et Thomé}

\begin{frame}{Algorithme de Barbulescu, Gaudry, Joux et Thomé}
  On note $\mathbb{K}$ le corps fini dans lequel on veut travailler.
  On suppose $\mathbb{K}=\mathbb{F}_{q^{2k}}$ et on on représente
  $\mathbb{K}$ par $\mathbb{F}_{q^2}[X]/(I_X)$, où $I_X$ est un polynôme
  irréductible de degré $k$ divisant $h_1X^q-h_0$.

\end{frame}

\begin{frame}{Contexte}
  Dans la pratique :
  \begin{enumerate}
    \item On a $\deg h_0 \leq 2$ et $\deg h_1 \leq 2$
    \item On considère $q \approx k$, ce qui implique $q\approx \log|\mathbb{K}|$
  \end{enumerate}

Le point $2$ est le cas optimal pour cet algorithme, tandis que le point $1$
constitue une \emph{heuristique}. Il y a plusieurs heuristiques dans cet
algorithme, et, plus généralement, dans les algorithmes de logarithme discret.
\end{frame}

\begin{frame}{L'algorithme}
  On considère $\mathbb{K} = \mathbb{F}_{q^2}[X]/(I_X)$, \ie on voit les
  éléments de $\mathbb{K}$ comme des polynômes à coefficient dans
  $\mathbb{F}_{q^2}$ de degré au plus $k$. Notre ensemble $F$ sera ici les
  polynômes de degré $1$.

  \begin{prop}
    Soit $\mathbb{K}$ un corps fini admettant une représentation via sous-corps
    creux moyen, il existe (sous certaines heuristiques) un algorithme de
    complexité polynomiale en $q$ et $k$ tel que :
    \begin{itemize}
      \item étant donné un élément de $\mathbb{K}$ représenté par un polynôme
        $P$, avec $2\leq \deg P \leq k-1$, on obtient $\log P$ en fonction d'au
        plus $O(kq^2)$ logarithmes $\log P_i$, avec $\deg P_i \leq \left\lceil
        \frac{1}{2}\deg P\right\rceil$, et de $\log h_1$
      \item on peut calculer le logarithme de $h_1(X)$ et des éléments de la
        forme $X+a$ où $a\in \mathbb{F}_{q^2}$
    \end{itemize}
  \end{prop}
  
\end{frame}

\begin{frame}{La complexité de la descente}
 L'algorithme issu de la proposition précédente est appelé algorithme de
 descente, on l'applique reccursivement jusqu'à obtenir $\log P$ en fonction des
 $\log(X + a_i)$.

 On obtient un arbre de descente dont chaque nœud correspond à un appel à
 l'algorithme de descente. L'arité de l'arbre est $O(q^2k)$ et sa profondeur
 $O(\log k)$. Le nombre de nœud est donc $(q^2k)^{O(\log k)}$.
\end{frame}

\begin{frame}{La descente}
 On va utiliser l'équation 
 \[
   X^q - X = \prod_{a\in\mathbb{F}_q}(X-a)
 \]
 qu'on transorme en
 \begin{equation}
   X^qY - XY^q = \prod_{(\alpha, \beta)\in\mathcal S}(\beta X - \alpha Y)
   \label{keyeq}
 \end{equation}
 où $\mathcal S$ est un ensemble de représentants des $q+1$ points de la droite
 projective $\mathbb{P}^1(\mathbb{F}_q)$ choisi tel que l'équation
 (\ref{keyeq}) soit vraie.
\end{frame}

\begin{frame}{La descente}
  Supposons qu'on souhaite appliquer l'algorithme à un élément $P$. On va
  générer des relations en substituant $aP + b$ à $X$ et $cP + d$ à $Y$ dans l'équation
  (\ref{keyeq}), avec $a, b, c, d \in \mathbb{F}_{q^2}$, on obtient une nouvelle
  équation $(E_{a, b, c, d})$. Il vient 
  \begin{eqnarray*}
 \prod_{(\alpha, \beta)\in\mathcal S}\beta (aP + b) - \alpha (cP + d) &=&
 \prod_{(\alpha, \beta)\in\mathcal S}(-c\alpha + a\beta)P - (d\alpha - b\beta) \\
 &=& \lambda \prod_{(\alpha, \beta)\in\mathcal S}(P-\mu_{\alpha, \beta})
  \end{eqnarray*}
  pour le côté droit, avec $\lambda, \mu_{\alpha, \beta}\in\mathbb{F}_{q^2}$.
  
\end{frame}

\begin{frame}{La descente}
  Pour le côté gauche, remarquons que $X^q = \frac{h_0(X)}{h_1(X)} \mod I_X$,
  ainsi $P(X)^q = \tilde P(X^q) = \tilde P(\frac{h_0(X)}{h_1(X)})$, où $\tilde
  P$ est le
  polynôme $P$ dont tous les coefficients ont été élevés à la puissance $q$.
  Cette astuce permet d'avoir un numérateur de degré au plus $3\deg P$ au lieu
  de $(q+1)\deg P$.

  On garde seulement les équations $(E_{a, b, c, d})$ dont le côté gauche est
  $\left\lceil \frac{\deg P}{2}\right\rceil$-friable et on combine ces équations
  pour que le côté droit, composé des translatés de $P$, ne fasse intervenir que
  $P$.

  La combinaison de ces équations donne alors un côté gauche composé seulement
  de polynômes de degré au plus $\left\lceil \frac{\deg P}{2}\right\rceil$.
  \begin{itemize}
    \item Attention aux heuristiques !
  \end{itemize}
\end{frame}


\subsection{Algorithme de Granger, Kleinjung et Zumbrägel}

\begin{frame}{Algorithme de Granger, Kleinjung et Zumbrägel}
  Ici $\mathbb{K}=\mathbb{F}_{q^k}$ et on voit $\mathbb{K}$ comme
  $\mathbb{F}_q[X]/(I_X)$ où $I_X$ est un polynôme de degré $k$ qui divise
  $h_1X^q-h_0$. L'algorithme suit le même principe que juste avant mais la phase
  de descente est différente. 
\end{frame}

\begin{frame}{Élimination ``à la volée''}
  Supposons $Q\in \mathbb{F}_{q^m}[X]$ et $\deg Q = 2$. Cette élimination se base
  sur le fait que le polynôme $P = X^{q+1}+aX^q+bX+c$ se scinde complètement
  dans $\mathbb{F}_{q^m}[X]$ pour
  environ $q^{m-3}$ triplets $(a, b, c)$. Or 
  \[
    P = \frac{1}{h_1}((X+a)h_0 + (bX+c)h_1)\mod I_X
  \]
  Donc si $Q| (X+a)h_0 + (bX+c)h_1$ (polynôme de degré $3$), on a 
  \[
    h_1P=QL \mod I_X
  \]
  où $L$ est de degré $1$ et $P$ se scinde complètement.

\end{frame}

\begin{frame}{Descente}
  Supposons maintenant $Q\in\mathbb{F}_{q}[X]$, irreductible et de degré $2d$.
  \[
    Q=\prod_{i=1}^d Q_i
  \]
  où les $Q_i$ sont des polynômes irreductibles de degré $2$ dans
  $\mathbb{F}_{q^d}[X]$ et sont tous conjugués. On applique alors
  l'élimination ``à la volée'' avec $Q_1$ pour obtenir $\log Q_1$ en fonction
  de $O(q)$ $\log P_i$ où les $P_i\in \mathbb{F}_{q^d}[X]$ sont de degré $1$.
  
  La norme d'un polynôme linéaire dans $\mathbb{F}_{q^d}[X]$ est un polynôme
  irréductible de degré $d_1$ à la puissance $d_2$, avec $d_1d_2 = d$.
  \emph{On a ainsi exprimé $\log Q$ en fonction de $O(q)$ $\log R_i$, où $\deg
  R_i | d$}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
